\chapter{Prototypische Voice-over-IP Konsolenanwendungen}
\label{prototypProgram}
\section{Ziel der Anwendung}

Um die Features des OHMComm-Framework zu zeigen wurde ein Prototypisches Voice-over-IP Programm als Konsolenanwendung realisiert. Ziel der Konsolenanwendung ist die Integration des Frameworks in ein Programm zu verdeutlichen. Außerdem wurden mit der Anwendung in rechnerübergreifenden Tests der Verbindungsaufbau, Verbindungsabbau und die Verbindungsqualitäts überprüft. Das Zusammenspiel der einzelnen Komponenten des OHMComm-Frameworks validiert und die Qualität der Audio Übertragung untersucht. 

\section{Verwendung der Schnittstelle des Frameworks}
Das OHMComm-Framework bietet eine sehr übersichtliche Schnittstelle, die verwendet werden muss, um das Framework in eine Anwendung einzubinden. Diese Schnittstelle ist eine Instanz der Klasse \texttt{OHMComm}, über die das gesamte Framework gesteuert werden kann. Um diese Schnittstelle nun verwenden zu können, muss ein \texttt{OHMComm}-Objekt erstellt werden. Dafür muss vorher eine Konfiguration als Instanz einer der \texttt{ConfigurationMode}-Kindklassen erstellt werden. Diese wird dem Konstruktor \texttt{OHMComm(ConfigurationMode*)} übergeben und das Framework kann verwendet werden. Daraufhin wird mit der Methode \texttt{isConfigurationDone\allowbreak{}(bool)} überprüft, ob die Konfiguration abgeschlossen ist, die über den Flag-Parameter gestartet werden kann, falls dies nicht so ist. Die restlichen Funktionalitäten werden danach automatisch, je nach übergebener Konfiguration, aktiviert und eingestellt. Damit ist das Framework vollständig eingestellt und die Kommunikation kann mit einem Methodenaufruf auf \texttt{startAudioThreads()} gestartet werden. Dieser Aufruf ist nicht blockierend, so dass der aufrufende Thread weitere Aktivitäten ausführen kann. Solang die Kommunikation läuft, gibt die Methode \texttt{isRunning()} \texttt{true} zurück. Beendet wird das Framework über die Methode \texttt{stopAudioThreads()}. Einen Beispielcode über die Verwendung des Frameworks liefert die prototypische Anwendung in der Datei \texttt{OHMCommStandalone.cpp}.
\section{Steuerung}
Die \texttt{main()}-Funktion aus \texttt{OHMCommStandalone.cpp} implementiert vier der fünf verfügbaren Konfigurationsmodi (siehe Abschnitt \ref{configurationUsages}). Die prototypische Konsolenanwendung kann also auf vier verschiedene Arten konfiguriert werden:
Wird das Programm ohne Kommandozeilenargumenten gestartet, wird die interaktive Konfiguration verwendet, bei der die benötigten Einstellungen nacheinander auf der Konsole mit möglichen Werten ausgegeben werden und der Benutzer durch Texteingabe die Einstellungen setzen muss.  Wird das Programm mit einem einzelnen Dateipfad als Parameter gestartet, werden die Einstellungen aus der übergebenen Datei geladen. Wenn das Kommandozeilenargument \texttt{-P} oder \texttt{--passive} gesetzt ist, wird die zusätzlich als Argument mit übergebene Netzwerkkonfiguration dazu verwendet, um eine Anfrage für eine passive Konfiguration an diese Adresse zu senden (siehe Abschnitt \ref{passiveConfiguration}). Der letzte implementierte Konfigurationsmodus ist die Parameterkonfiguration, bei der alle Einstellungen als Kommandozeilenargumente an den Programmaufruf angehängt werden, wobei mit \texttt{-h} oder \texttt{--help} eine Übersicht über alle möglichen Einstellungen ausgegeben werden kann.
\section{Anwendungen ordnungsgemäß beenden}
Ein größeres Problem bei der Umsetzung der prototypischen Konsolenanwendung ist es gewesen, die Anwendung ordnungsgemäß zu beenden. Besonders problematisch wird es, da die Anwendung aus verschiedenen Threads besteht, die alle beendet werden müssen, sowie die Kommunikation selber aus verschiedenen Threads heraus beendet werden kann. So müssen folgende Threads beendet werden: Der Thread der Verarbeitungskette, der von der Audioschnittstelle heraus gestartet wird, der RTPListener-Thread und der RTCP-Thread, die beide vom \texttt{OHMComm}-Objekt erzeugt werden. Ebenso muss der \texttt{NetworkWrapper} geschlossen werden, da dieser auch verbindungsorientiert (z.B. mit TCP) implementiert werden kann. Beendet werden kann das Framework an folgenden Stellen: von Extern (z.B. der verwendenden Anwendung) und durch den RTCP-Thread (beim Empfangen eines \texttt{BYE}-Pakets). Daher muss dafür gesorgt werden, dass sowohl der aufrufende Code als auch der RTCP-Thread Zugriff auf die \texttt{stopAudioThreads()}-Methode des \texttt{OHMComm}-Objekts haben. Dafür wird dem RTCP-Thread ein Funktionsobjekt mitgegeben, das die \texttt{stopAudioThreads()}-Methode aufruft, die dafür sorgt, dass alle vom Framework erstellten Threads und Resource-Handler ordnungsgemäß beendet und geschlossen werden.
\\
Somit kann die Kommunikation im OMHComm-Framework durch den Aufruf der \texttt{stopAudioThreads()}-Methode aus allen Stellen, die Zugriff darauf haben ordnungsgemäß und vollständig beendet werden. Jedoch wird die Kommunikation im Framework durch einen nicht blockierenden Methodenaufruf auf \texttt{startAudio\-Threads()} gestartet, damit der aufrufende Thread weitere Tätigkeiten ausführen kann. Da aber ein Programm automatisch beendet wird, wenn die \texttt{main()}-Funktion ihr Ende erreicht, muss für die prototypische Konsolenanwendung der Haupt-Thread nach dem Start der Kommunikation solange schlafen gelegt werden, bis die Kommunikation beendet wird. Dafür wird in der \texttt{main()}-Funktion blockierend auf eine Benutzereingabe gewartet und nach dieser Eingabe die Kommunikation und schließlich das Programm beendet. Wird jedoch die Kommunikation über einen anderen Weg (z.B. durch das Empfangen eines RTCP \texttt{BYE}-Pakets) beendet, wartet der Haupt-Thread weiterhin auf eine Benutzereingabe und somit läuft das Konsolenprogramm weiter. Deshalb muss derzeit die Konsolenanwendung immer mit einer Benutzereingabe (beliebige Zeichen, die mit einem \enquote{Enter} abgesendet werden) beendet werden.
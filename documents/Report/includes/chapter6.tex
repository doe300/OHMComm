\chapter{Schlussbemerkungen}

\section{Ausblick}

\subsection{Anwendungsmöglichkeiten}
OHMComm kann als vollständiges und plattformunabhängiges Audiokommunikationsframework in anderen externen Softwarelösungen integriert werden. Als Schnittstelle nach außen bietet das Framework dafür ein \texttt{OHMComm}-Objekt an, welches erstellt, konfiguriert (bevorzugt über die \texttt{LibraryConfiguration}) und gestartet werden muss. Die gesamte Aktivität des Frameworks wird in separaten Threads (für Audioverarbeitung, Empfangen,, RTCP, ...) ausgelagert. So wird sichergestellt, dass die aufrufende Anwendung nicht blockiert wird. Durch vollständigen Funktionsumfang und wohldefinierten Schnittstellen lässt sich OHMComm einfach in andere Anwendungen integrieren.
Kapitel \ref{prototypProgram} zeigt ein vollständiges Anwendungsbeispiel für die Audioübertragung zwischen zwei Geräten mit OHMComm. Am Beispiel lassen sich sehr einfach die verschiedenen Konfigurationsmodi und Einstellungsmöglichkeiten ausprobieren. Der Code dazu (bestehend aus der Datei \texttt{OHMCommStandalone.cpp}) zeigt ein kurzes und vollständiges Beispiel, wie das Framework richtig eingebunden werden kann.
TODO: erweitern? richtig?

\subsection{Erweiterungsmöglichkeiten}
Aufgrund des modularen Aufbaus des kompletten Frameworks, lässt es sich sehr einfach erweitern. Vorgesehene Erweiterungen für das Framework gliedern sich in die folgenden Kategorien:
\begin{description}
\item[Parameter:] Alle existierenden Parameter können -- soweit einmal registriert -- von allen Audioprozessoren verwendet werden. Ebenso ist es sehr einfach, neue Parameter zu registrieren, die bei der Konfiguration des Frameworks automatisch beachtet und mit Werten versehen werden.
\item[Audioschnittstellen:] Derzeit wird als einzige Schnittstelle zur Audiohardware die Bibliothek RTAudio verwendet. Jedoch kann die Audiobibliothek einfach ausgetauscht werden, indem eine neue Kindklasse von \texttt{AudioHandler} erstellt und zur \texttt{AudioHandlerFactory} hinzugefügt wird, die auf einer anderen Audiobibliothek aufbaut. So könnte z.B. PortAudio, eine plattformunabhängige C-Audioschnittstelle, angebunden werden.
\item[Audioprozessoren:] In die Verarbeitungskette (siehe Abschnitt \ref{processingChain}) können beliebige neue Prozessoren für Audiodaten hinzugefügt werden. Dafür muss nur die neu erstellte Kindklasse von \texttt{AudioProcessor} in \texttt{AudioProcessorFactory} registriert werden und beim Start der Anwendung ausgewählt werden. Ebenso können -- wie bereits erwähnt -- neue Parameter für die Konfiguration der neuen Audioprozessoren registriert werden.
\item[Netzwerkschnittstellen:] Auch neue Schnittstellen für Netzwerkprotokolle, wie TCP, lassen sich durch Erstellen neuer Kindklassen von \texttt{NetworkWrapper} und Ersetzen der Aufrufe von \texttt{UDPWrapper} hinzufügen.
\end{description}
Derzeit sind Erweiterungen zu dem bestehenden Framework in Planung oder bereits in Entwicklung, wie die Konfiguration über das Session Initiation Protocol (SIP), sowie den Audiocodecs G.711 A-law und $\mu$-law, den Standardformaten der digitalen Telefonie.
\\
Im Allgemeinen können in die bestehende Architektur eine Vielzahl an zusätzlichen Funktionalitäten fest oder auch optional hinzugefügt werden. So z.B. weitere Audiocodecs, Hochpass- oder Tiefpassfilter zum Herausfiltern von Rauschen oder Hintergrundgeräuschen, Verstärker für die Lautstärke des abgespielten Signals, Prozessoren, die die Audiokonversation mitschneiden und viele mehr.

\section{Fazit}
Das Hauptziel des Projektes war die Erstellung eines plattformunabhängigen Audiokommunikationsframework. Dieses Ziel wurde im Rahmen des IT-Projektes erreicht, da alle funktionalen und nicht-funktionalen Anforderungen umgesetzt worden sind.
Es wurde eine abstrakte und austauschbare Schnittstelle zur Hardware geschaffen, welche ebenfalls die Architektur zur Audioverarbeitung beinhaltete (Verarbeitungskette). Dadurch konnten andere Klassen aktiv an der Audioverarbeitung teilnehmen. Die konkrete Implementierung dieser abstrakten Klasse basierte dabei auf RtAudio.
Mit Opus wurde ein effizienter Audiocodec eingefügt, welcher die zuvor erstellte Schnittstelle zur Verarbeitungskette nutzte. Das RTP-Protokoll wurde vollständig gemäß dem Standard implementiert und auf Basis des UDP-Protokolls versendet. Empfangene Pakete wurden im Jitter-Buffer sortiert eingefügt. Dieser puffert Pakete bis eine Mindestanzahl erreicht wurde, bevor diese zum Abspielen verfügbar waren. Alle erstellten Funktionalitäten wurden in einer Beispielanwendungen getestet. Die statistische gesammelten Werte bestätigten die Effizienz des Frameworks sowie die Qualität des Opus-Codec. Obwohl das Projekt erfolgreich war, gibt es Kritikpunkte. Das Umsetzen von objektorientierten Prinzipien hätte besser erfolgen können, da die Integration von den angewandten Pattern nicht perfekt war. Der Grund war, dass die entsprechende Vorlesung dazu parallel zum Entwicklungszeitpunkt verlief. Ein weiterer Kritikpunkt war, dass von Anfang an hätten Code-Konventionen angewendet werden sollten für einen einheitlichen sauberen Code. Der Code entspricht einer Mischung von C++11 und C++03.


